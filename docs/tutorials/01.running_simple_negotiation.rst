Running a Negotiation
---------------------

NegMAS has several built-in negotiation ``Mechanism`` s, negotiation
agents (``Negotiator`` s), and ``UtilityFunction`` s. You can use these
to run negotiations as follows:

.. code:: ipython3

    import random # for generating random ufuns
    random.seed(0) # for reproducibility
    from pprint import pprint # for printing
    from negmas import SAOMechanism, AspirationNegotiator, MappingUtilityFunction

    session = SAOMechanism(outcomes=10, n_steps=100)
    negotiators = [AspirationNegotiator(name=f'a{_}') for _ in range(5)]
    for negotiator in negotiators:
        session.add(negotiator, preferences=MappingUtilityFunction(lambda x: random.random() * x[0]))

    pprint(vars(session.run()))


.. parsed-literal::

    {'agreement': (8,),
     'broken': False,
     'current_offer': (8,),
     'current_proposer': 'a1-fe37f235-df3a-4745-a3da-e1645a0f29f1',
     'current_proposer_agent': None,
     'error_details': '',
     'has_error': False,
     'last_negotiator': 'a0',
     'n_acceptances': 0,
     'n_negotiators': 5,
     'new_offerer_agents': [],
     'new_offers': [],
     'relative_time': 0.7821782178217822,
     'results': None,
     'running': False,
     'started': True,
     'step': 78,
     'time': 6.3316177379999985,
     'timedout': False,
     'waiting': False}


Negotations end with a status that shows you what happens. In the above
example, we can see that the negotiation was not broken and did not
time-out. The agreement was on outcome ``(9,)`` of the *10* possible
outcomes of this negotiation. That offer was offered by negotiator
``a3`` (the rest of the agent *ID* is always a random value to ensure no
name repetitions) in the ``9``\ th round of the negotiation
(rounds/steps start at ``0``) and was accepted by all of the other *4*
negotiators. The whole negotiation took ``4.66`` ms.

Let’s look at this code example line-by-line:

.. code:: python

   session = SAOMechanism(outcomes=10, n_steps=100)

The negotiation protocol in NegMAS is handled by a ``Mechanism`` object.
Here we instantiate an ``SAOMechanism`` which implements the `Stacked
Alternating Offers
Protocol <https://ii.tudelft.nl/~catholijn/publications/sites/default/files/Aydogan2017_Chapter_AlternatingOffersProtocolsForM.pdf>`__.
In this protocol, negotiators exchange offers until an offer is accepted
by all negotiators, a negotiators leaves the table ending the
negotiation or a time-out condition is met. In the example above, we use
a limit on the number of rounds (defined by a number of offers equal to
the number of negotiators) of ``100`` (a step of a mechanism is an
executed round). Another possibility here is to pass a wall-time
constraint using something like ``time_limit=10`` which limits the
negotiation to ``10`` seconds.

The negotiation agenda can be specified in two ways:

1. You can pass ``outcomes=x`` to create a negotiation agenda with a
   single issue of ``x`` values. In this example we use this approach to
   create a single issue negotiation with ``10`` outcomes. These
   outcomes will be tuples of one item each ranging from ``(0,)`` to
   ``(9,)``.
2. You can pass ``issues=x`` to create a multi-issue negotiation as we
   will see later in this tutorial. We can use this approach to achieve
   the same result as above by replacing ``outcomes=10`` with
   ``issues=[make_issue(10)]`` in the sample code above.

.. code:: python

   negotiators = [AspirationNegotiator(name=f"a{_}") for _ in range(5)]

This line creates ``5`` negotiators of the type ``AspirationNegotiator``
which implements a simple time-based negotiation strategy. It starts by
offering the outcome with maximum utility for itself and then concedes
(i.e. offers outcomes with lower utility) based on the relative time of
the negotiation.

.. code:: python

   for negotiator in negotiators:
       session.add(
           negotiator, preferences=MappingUtilityFunction(lambda x: random.random() * x[0])
       )

This loop *adds* the negotiators to the negotiation session (the
``SAOMechanism`` we created earlier). Most negotiators need access to a
utility function that defines its preferences over different outcomes.
Here we use a ``MappintUtilityFunction`` which is passed any python
callable (i.e. a function, lambda expression, a class implementing
``__call__``, …) and uses it to calculate the utility of a given
outcome.

The lambda expression used here (``lambda x: random.random() * x[0]``)
extracts the first value of the outcome (which will be an integer from
``0`` to ``9``) and multiplies it with a random number *each time it is
called*. This means that calling this utility function twice with the
same outcome results in two different values. This may not be
particularly useful but it shows that the utility function can *change*
during the negotiation and NegMAS provides some support for this which
we will discuss in later tutorials.

Now the last line runs the negotiation using the ``run()`` method of the
``SAOMechanism`` object, converts the result to a dictionary using
``var`` and prints it.

A simple bilateral negotiation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let’s try a more meaningful situation: Assume we have a buyer and a
seller who are negotiating about a business transaction in which the
buyer wants to maximize his profit while the seller wants to minimize
her cost. They both would like to transact on as much as possible of the
product and each has some preferred delivery time.

This can be modeled in the following negotiation:

.. code:: ipython3

    from negmas import make_issue, SAOMechanism, NaiveTitForTatNegotiator, AspirationNegotiator
    from negmas.preferences import LinearAdditiveUtilityFunction as LUFun
    from negmas.preferences.value_fun import LinearFun, IdentityFun, AffineFun

    # create negotiation agenda (issues)
    issues = [
        make_issue(name='price', values=10),
        make_issue(name='quantity', values=(1, 11)),
        make_issue(name='delivery_time', values=10)
    ]

    # create the mechanism
    session = SAOMechanism(issues=issues, n_steps=20)

    # define buyer and seller utilities
    seller_utility =  LUFun(
            values=[
                IdentityFun(),
                LinearFun(0.2),
                AffineFun(-1, bias=9.0)
            ],
            outcome_space=session.outcome_space
        )

    buyer_utility = LUFun(
            values={
                'price': AffineFun(-1, bias=9.0),
                'quantity': LinearFun(0.2),
                'delivery_time': IdentityFun()
            },
            outcome_space=session.outcome_space
        )

    # create and add buyer and seller negotiators
    session.add(AspirationNegotiator(name='buyer'), preferences=buyer_utility)
    session.add(NaiveTitForTatNegotiator(name='seller'), ufun=seller_utility)

    # run the negotiation and show the results
    pprint(vars(session.run()))


.. parsed-literal::

    {'agreement': (8, 9, 9),
     'broken': False,
     'current_offer': (8, 9, 9),
     'current_proposer': 'buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2',
     'current_proposer_agent': None,
     'error_details': '',
     'has_error': False,
     'last_negotiator': 'seller',
     'n_acceptances': 0,
     'n_negotiators': 2,
     'new_offerer_agents': [None],
     'new_offers': [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (8, 9, 9))],
     'relative_time': 0.8571428571428571,
     'results': None,
     'running': False,
     'started': True,
     'step': 17,
     'time': 0.174903982,
     'timedout': False,
     'waiting': False}


In this run, we can see that the agreement was on a high price (*9*)
which is preferred by the seller but with a delivery time of *8* which
is preferred by the buyer. Negotiation took *17* steps out of the
allowed *20* (*90%* of the available time)

We can check the negotiation history as well

.. code:: ipython3

    for i, _ in enumerate(session.history):
        print(f'{i:03}: {_.new_offers}')


.. parsed-literal::

    000: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (9, 11, 0))]
    001: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (9, 10, 0))]
    002: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (9, 9, 0))]
    003: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (9, 8, 0))]
    004: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (9, 7, 0))]
    005: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (8, 11, 0))]
    006: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 10, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (8, 10, 0))]
    007: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 9, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (8, 9, 0))]
    008: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (0, 8, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (8, 8, 0))]
    009: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (1, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (6, 9, 0))]
    010: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (1, 9, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (6, 8, 0))]
    011: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (2, 11, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (4, 11, 0))]
    012: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (2, 7, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (4, 10, 0))]
    013: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (3, 7, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (3, 9, 0))]
    014: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (5, 10, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (0, 11, 0))]
    015: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (6, 8, 9)), ('seller-23435637-5534-4b50-adaa-4db8217a52ac', (0, 7, 0))]
    016: [('buyer-c6b60895-4c79-4e7f-8f1a-06582cc1fac2', (8, 9, 9))]


We can even plot the complete negotiation history and visually see how
far were the result from the pareto frontier (it was 0.0 utility units
far from it).

.. code:: ipython3

    session.plot()



.. image:: 01.running_simple_negotiation_files/01.running_simple_negotiation_9_0.png



.. parsed-literal::

    <Figure size 1440x576 with 0 Axes>


What happens if the seller was much more interested in delivery time.

Firstly, what do you expect?

Given that delivery time becomes a more important issue now, the seller
will get more utility points by allowing the price to go down given that
the delivery time can be made earlier. This means that we should expect
the delivery time and price to go down. Let’s see what happens:

.. code:: ipython3

    seller_utility = LUFun(values={'price': IdentityFun() , 'quantity': LinearFun(0.2) , 'delivery_time': AffineFun(-1, bias=9)},
                           weights = {'price': 1.0, 'quantity': 1.0, 'delivery_time': 10.0},
                           outcome_space=session.outcome_space)

    session = SAOMechanism(issues=issues, n_steps=50)
    session.add(AspirationNegotiator(name='buyer'), ufun=buyer_utility)
    session.add(AspirationNegotiator(name='seller'), ufun=seller_utility)
    pprint(session.run().__dict__)


.. parsed-literal::

    {'agreement': (5, 2, 5),
     'broken': False,
     'current_offer': (5, 2, 5),
     'current_proposer': 'seller-8cb1537b-27c8-448c-ab8f-1ff01424ece4',
     'current_proposer_agent': None,
     'error_details': '',
     'has_error': False,
     'last_negotiator': 'buyer',
     'n_acceptances': 0,
     'n_negotiators': 2,
     'new_offerer_agents': [],
     'new_offers': [],
     'relative_time': 0.9019607843137255,
     'results': None,
     'running': False,
     'started': True,
     'step': 45,
     'time': 1.8555690819999988,
     'timedout': False,
     'waiting': False}


We can check it visually as well:

.. code:: ipython3

    session.plot()



.. image:: 01.running_simple_negotiation_files/01.running_simple_negotiation_13_0.png



.. parsed-literal::

    <Figure size 1440x576 with 0 Axes>


It is clear that the new ufuns transformed the problem. Now we have many
outcomes that are far from the pareto-front in this case. Nevertheless,
there is money on the table as the negotiators did not agree on an
outcome on the pareto front.

Inspecting the utility ranges of the seller and buyer we can see that
the seller can get much higher utility than the buyer (100 comapred with
20). This is a side effect of the ufun definitions and we can remove
this difference by normalizing both ufuns and trying again:

.. code:: ipython3

    seller_utility = seller_utility.scale_max(1.0)
    buyer_utility = buyer_utility.scale_max(1.0)
    session = SAOMechanism(issues=issues, n_steps=50)
    session.add(AspirationNegotiator(name='buyer'), ufun=buyer_utility)
    session.add(AspirationNegotiator(name='seller'), ufun=seller_utility)
    session.run()
    session.plot(ylimits=(0.0, 1.01))



.. image:: 01.running_simple_negotiation_files/01.running_simple_negotiation_15_0.png



.. parsed-literal::

    <Figure size 1440x576 with 0 Axes>


What happens if we give them more time to negotiate:

.. code:: ipython3

    session = SAOMechanism(issues=issues, n_steps=5000)

    session.add(AspirationNegotiator(name='buyer'), ufun=buyer_utility)
    session.add(AspirationNegotiator(name='seller'), ufun=seller_utility)
    session.run()
    session.plot(ylimits=(0.0, 1.01))



.. image:: 01.running_simple_negotiation_files/01.running_simple_negotiation_17_0.png



.. parsed-literal::

    <Figure size 1440x576 with 0 Axes>


It did not help much! The two agents adjusted their concession to match
the new time and they did not get to the Pareto-front.

Let’s allow them to concede faster by setting their ``aspiration_type``
to *linear* instead of the default *boulware*:

.. code:: ipython3

    session = SAOMechanism(issues=issues, n_steps=5000)
    session.add(AspirationNegotiator(name='buyer', aspiration_type="linear"), ufun=buyer_utility)
    session.add(AspirationNegotiator(name='seller', aspiration_type="linear"), ufun=seller_utility)
    session.run()
    session.plot(ylimits=(0.0, 1.01))



.. image:: 01.running_simple_negotiation_files/01.running_simple_negotiation_19_0.png



.. parsed-literal::

    <Figure size 1440x576 with 0 Axes>


It is clear that longer negotiation time, and faster concession did not
help the negotiators get to a point on the pareto-front.

What happens if one of the negotiators (say the buyer) was tougher than
the other?

.. code:: ipython3

    session = SAOMechanism(issues=issues, n_steps=5000)
    session.add(AspirationNegotiator(name='buyer', aspiration_type="boulware"), ufun=buyer_utility)
    session.add(AspirationNegotiator(name='seller', aspiration_type="linear"), ufun=seller_utility)
    session.run()
    session.plot(ylimits=(0.0, 1.01))



.. image:: 01.running_simple_negotiation_files/01.running_simple_negotiation_21_0.png



.. parsed-literal::

    <Figure size 1440x576 with 0 Axes>


Try to give an intuition for what happened:

-  Why did the negotiation take shorter than the previous one?
-  Why is the final agreement nearer to the pareto front?
-  Why is the buyer getting higher utility than in the case before the
   previous (in which it was also using a Boulware strategy)?
-  Why is the seller getting lower utility than in the case before the
   previous (in which it was also using a linear concession strategy)?
-  If the seller knew that the buyer will be using this strategy, what
   is its best response?
